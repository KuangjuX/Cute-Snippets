"""
htile.types.register

This module provides abstractions for register-level tiles (RegTile, VectorRegTile)
that wrap around cutlass.cute fragments with explicit layouts. The implementation
enables both flexible and declarative register fragment generation using CuTe's
make_fragment and make_layout primitives.

Design Motivation
-----------------
Inspired by the TileFusion philosophy, the design aims to allow the static
derivation of the register tile shape and layout for each thread directly from
vector/block-level copy or computation plans—without requiring runtime inference.
In particular, VectorRegTile is capable of constructing a register tile whose shape
matches the partitioning scheme implied by a VectorCopy configuration. This is
useful for both performance modeling and kernel code generation.

Derivation
----------
Given a VectorCopy's TiledCopy built from:

    vec_size     = 128 // dtype.width
    val_M        = 1                           (val_layout[0])
    rows_per_block = num_threads // threads_per_row
    num_block_N  = ⌈(N // vec_size) / (threads_per_row × cluster_n)⌉

    tile_M = rows_per_block
    tile_N = vec_size × threads_per_row × num_block_N

    rep_M = tile_M / (rows_per_block × val_M)  → 1
    rep_N = num_block_N

    fragment_shape = ((vec_size, 1), 1, num_block_N)

Usage Example
-------------
from htile import VectorCopy, VectorRegTile

# Method 1: Direct construction
reg = VectorRegTile(dtype=Float16, threads_per_row=128, num_threads=128, N=16384)
print(reg)
# VectorRegTile(dtype=Float16, shape=((8, 1), 1, 16), tile=(1, 16384), elems_per_thread=128)
print(reg.tiler_mn)           # (1, 16384)
print(reg.fragment_shape())   # ((8, 1), 1, 16)

# Method 2: Derive from VectorCopy (for config consistency)
vc = VectorCopy(dtype=Float16, threads_per_row=128, num_threads=128, num_copy_elems=8)
reg = VectorRegTile.from_vector_copy(vc, N=16384)

# In @cute.kernel, can replace make_fragment_like(partition_result):
# Old:  tXrX = cute.make_fragment_like(tXgX)
# Now:  tXrX = reg.make_fragment()

Experimental Notes
------------------
This file contains an experimental implementation, partially generated by Claude Opus 4.6,
for exploring advanced static tile inference and code generation within the HTile and
CuTe ecosystem.
"""

import math
from typing import Type

import cutlass
import cutlass.cute as cute


class RegTile:
    """Basic register tile wrapping a CuTe fragment with an explicit layout.

    Used when the layout is already known (e.g., passed in directly).
    The fragment is created at JIT/trace time via cute.make_fragment.
    """

    def __init__(
        self,
        dtype: Type[cutlass.Numeric],
        layout: cute.Layout,
    ):
        self.data = cute.make_fragment(layout, dtype)
        self.layout = layout
        self.dtype = dtype


class VectorRegTile:
    """Register tile for vector copy patterns with STATIC layout derivation.

    Problem
    -------
    In CuTe DSL, register fragment layouts emerge from the partition chain:

        tXgX = thr_copy.partition_S(gX)       # shape determined here
        tXrX = cute.make_fragment_like(tXgX)   # fragment inherits shape

    The fragment shape is a RESULT of (TiledCopy config × tile shape),
    not an independently declarable input.  You cannot first declare a
    RegTile and then have partition adapt to it.

    Solution
    --------
    For vector load/store patterns using make_tiled_copy_tv, the per-thread
    partition result's shape is DETERMINISTIC given the copy plan parameters.
    This class performs the equivalent static derivation.

    Derivation
    ----------
    Given a VectorCopy's TiledCopy built from:

        copy_atom:  128-bit vector → vec_size = 128 // dtype.width elements
        thr_layout: (rows_per_block, threads_per_row), order=(1, 0)
        val_layout: (val_M=1, vec_size)

    The atom tile covers:
        (rows_per_block × val_M, threads_per_row × vec_size) elements.

    For a target tile with shape tiler_mn = (tile_M, tile_N):
        rep_M = tile_M / (rows_per_block × val_M)
        rep_N = tile_N / (threads_per_row × vec_size) = num_block_N

    Per-thread partition result shape (verified by reverse-engineering
    predicate_k and vector_copy access patterns):

        ((vec_size, val_M), rep_M, rep_N)
            ↑ mode 0        ↑ mode 1  ↑ mode 2

    Where:
        shape[0]    = (vec_size, val_M)  — nested value mode
        shape[0][0] = vec_size           — vectorization width (used by vector_copy)
        shape[0][1] = val_M              — M-direction values per copy instruction
        shape[1]    = rep_M              — M-direction tile repetitions
        shape[2]    = rep_N              — N-direction block iterations

    Evidence (how we know the exact nesting):
        1. vector_copy:   num_copy_elems = src.shape[0][0]
           → mode 0 is a tuple, sub-dim 0 = vec_size
        2. predicate_k:   tAcA[(0, rest_v), 0, rest_k]
           → mode 0 has 2 sub-dimensions: (vec_dim, val_M_dim)
        3. predicate_k:   cute.size(tAcA, mode=[0, 1]) extracts val_M
           → sub-dim 1 of mode 0 = val_M

    Relationship to TileFusion
    --------------------------
    TileFusion's RegTile<BaseTile, TileOfBaseTiles> is designed for MMA
    patterns where BaseTile shape is anchored to TensorCore instruction
    shapes (e.g., 16×8×8 for wmma).

    For vector load/store patterns (elementwise ops, reductions, softmax),
    there is no hardware-mandated register layout.  The "base unit" is
    simply the vectorization width (vec_size), and the register tile is
    a flat collection of vector blocks.  This class fills that gap.
    """

    def __init__(
        self,
        dtype: Type[cutlass.Numeric],
        threads_per_row: int,
        num_threads: int,
        N: int,
        cluster_n: int = 1,
    ):
        self.dtype = dtype
        self.threads_per_row = threads_per_row
        self.num_threads = num_threads
        self.N = N
        self.cluster_n = cluster_n

        # ---- Static layout derivation ----

        # Vectorization width: elements per 128-bit copy instruction
        self.vec_size = 128 // dtype.width

        # val_layout M-component: values in M direction per thread per copy.
        # For VectorCopy, val_layout = (1, vec_size), so val_M is always 1.
        self.val_M = 1

        # Thread layout decomposition
        self.rows_per_block = num_threads // threads_per_row

        # N-dimension blocking
        self.num_block_N = math.ceil(
            (N // self.vec_size) / (threads_per_row * cluster_n)
        )

        # ---- Derived tile dimensions ----

        # What one CTA (+ cluster slice) processes
        self.tile_M = self.rows_per_block
        self.tile_N = self.vec_size * threads_per_row * self.num_block_N

        # Atom tile: one round of all-threads copy covers this region
        self._atom_M = self.rows_per_block * self.val_M
        self._atom_N = threads_per_row * self.vec_size

        # ---- Per-thread repetitions ----
        self.rep_M = self.tile_M // self._atom_M  # typically 1
        self.rep_N = self.num_block_N

        # Total elements per thread
        self.num_elems = self.vec_size * self.val_M * self.rep_M * self.rep_N

    # ------------------------------------------------------------------
    # Properties
    # ------------------------------------------------------------------

    @property
    def tiler_mn(self) -> tuple[int, int]:
        """Tile shape for cute.local_tile — a derived property.

        Equivalent to the tiler_mn computed in Softmax.__call__:
            tiler_mn = (num_threads // threads_per_row,
                        vec_size * threads_per_row * num_block_N)
        """
        return (self.tile_M, self.tile_N)

    def fragment_shape(self) -> tuple:
        """Per-thread fragment shape: ((vec_size, val_M), rep_M, rep_N).

        This matches the shape produced by:
            cute.make_fragment_like(thr_copy.partition_S(tile))
        but computed purely from static parameters.

        Key invariants:
            fragment_shape()[0][0] == vec_size   (required by vector_copy)
            fragment_shape()[0][1] == val_M      (required by predicate_k)
            fragment_shape()[1]    == rep_M
            fragment_shape()[2]    == rep_N == num_block_N
        """
        return ((self.vec_size, self.val_M), self.rep_M, self.rep_N)

    # ------------------------------------------------------------------
    # JIT-time fragment construction
    # ------------------------------------------------------------------

    @cute.jit
    def make_layout(self) -> cute.Layout:
        """Create a CuTe Layout matching the derived fragment shape."""
        return cute.make_layout(
            ((self.vec_size, self.val_M), self.rep_M, self.rep_N)
        )

    @cute.jit
    def make_fragment(self) -> cute.Tensor:
        """Create a register fragment with the statically derived layout.

        Equivalent to the partition-based idiom:
            thr = tiled_copy.get_slice(tidx)
            partitioned = thr.partition_S(tile)
            frag = cute.make_fragment_like(partitioned)
        but without requiring partition_S/D at all.
        """
        return cute.make_fragment(self.make_layout(), self.dtype)

    # ------------------------------------------------------------------
    # Factory methods
    # ------------------------------------------------------------------

    @classmethod
    def from_vector_copy(cls, vector_copy, N: int, cluster_n: int = 1):
        """Derive a VectorRegTile from a VectorCopy instance.

        This lets you construct the register tile descriptor directly
        from the same VectorCopy that builds the TiledCopy, ensuring
        consistency.

        Args:
            vector_copy: VectorCopy instance defining the copy plan.
            N: Size of the last (reduction) dimension.
            cluster_n: Cluster size (default 1).

        Example::

            vc = VectorCopy(dtype=Float16, threads_per_row=128,
                            num_threads=128, num_copy_elems=8)
            reg = VectorRegTile.from_vector_copy(vc, N=16384)
            print(reg)
            # VectorRegTile(dtype=Float16, shape=((8, 1), 1, 16),
            #               tile=(1, 16384), elems=128)
        """
        return cls(
            dtype=vector_copy.dtype,
            threads_per_row=vector_copy.threads_per_row,
            num_threads=vector_copy.num_threads,
            N=N,
            cluster_n=cluster_n,
        )

    # ------------------------------------------------------------------
    # Debugging
    # ------------------------------------------------------------------

    def __repr__(self):
        shape = self.fragment_shape()
        return (
            f"VectorRegTile("
            f"dtype={self.dtype.__name__}, "
            f"shape={shape}, "
            f"tile=({self.tile_M}, {self.tile_N}), "
            f"elems_per_thread={self.num_elems})"
        )
